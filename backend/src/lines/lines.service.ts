import { Injectable, NotFoundException, BadRequestException, Inject, forwardRef } from '@nestjs/common';
import { PrismaService } from '../prisma.service';
import { CreateLineDto } from './dto/create-line.dto';
import { UpdateLineDto } from './dto/update-line.dto';
import { WebsocketGateway } from '../websocket/websocket.gateway';
import { ControlPanelService } from '../control-panel/control-panel.service';
import { SystemEventsService, EventType, EventModule, EventSeverity } from '../system-events/system-events.service';
import axios from 'axios';

@Injectable()
export class LinesService {
  constructor(
    private prisma: PrismaService,
    @Inject(forwardRef(() => WebsocketGateway))
    private websocketGateway: WebsocketGateway,
    private controlPanelService: ControlPanelService,
    private systemEventsService: SystemEventsService,
  ) {}

  async create(createLineDto: CreateLineDto, createdBy?: number) {
    console.log('üìù Dados recebidos no service:', JSON.stringify(createLineDto, null, 2));

    // Limpar strings vazias e converter para null
    if (createLineDto.token === '') createLineDto.token = null;
    if (createLineDto.businessID === '') createLineDto.businessID = null;
    if (createLineDto.numberId === '') createLineDto.numberId = null;

    console.log('üìù Dados ap√≥s limpeza:', JSON.stringify(createLineDto, null, 2));

    // Verificar se j√° existe uma linha com este telefone
    const existingLine = await this.prisma.linesStock.findUnique({
      where: { phone: createLineDto.phone },
    });

    if (existingLine) {
      throw new BadRequestException('J√° existe uma linha com este telefone');
    }

    // Buscar configura√ß√£o da Evolution
    const evolution = await this.prisma.evolution.findUnique({
      where: { evolutionName: createLineDto.evolutionName },
    });

    if (!evolution) {
      throw new NotFoundException(`Evolution "${createLineDto.evolutionName}" n√£o encontrada. Evolutions dispon√≠veis: ${await this.getAvailableEvolutionNames()}`);
    }

    // Testar conex√£o com Evolution antes de criar inst√¢ncia
    try {
      console.log('üîç Testando conex√£o com Evolution:', evolution.evolutionUrl);

      const testResponse = await axios.get(
        `${evolution.evolutionUrl}/manager/getInstances`,
        {
          headers: {
            'apikey': evolution.evolutionKey,
          },
          timeout: 10000,
        }
      );

      console.log('‚úÖ Conex√£o com Evolution OK. Inst√¢ncias encontradas:', testResponse.data?.length || 0);
    } catch (testError) {
      console.error('‚ùå Falha ao conectar com Evolution:', {
        url: evolution.evolutionUrl,
        error: testError.message,
        response: testError.response?.data,
        status: testError.response?.status,
      });
      throw new BadRequestException(
        `N√£o foi poss√≠vel conectar √† Evolution API. Verifique a URL (${evolution.evolutionUrl}) e a chave da Evolution "${evolution.evolutionName}".`
      );
    }

    // Criar inst√¢ncia na Evolution API
    try {
      const instanceName = `line_${createLineDto.phone.replace(/\D/g, '')}`;
      const webhookUrl = `${process.env.APP_URL || 'http://localhost:3000'}/webhooks/evolution`;

      const requestData = {
        instanceName,
        qrcode: true,
        integration: 'WHATSAPP-BAILEYS',
      };

      console.log('üì° Criando inst√¢ncia na Evolution:', {
        instanceName,
        evolutionUrl: evolution.evolutionUrl,
        requestData,
      });

      // Criar inst√¢ncia
      const createResponse = await axios.post(
        `${evolution.evolutionUrl}/instance/create`,
        requestData,
        {
          headers: {
            'apikey': evolution.evolutionKey,
            'Content-Type': 'application/json',
          },
          timeout: 30000,
        }
      );

      console.log('‚úÖ Inst√¢ncia criada:', {
        instanceName,
        response: createResponse.data,
      });

      // Configurar webhook separadamente (aguardar 2 segundos para garantir que a inst√¢ncia est√° pronta)
      await new Promise(resolve => setTimeout(resolve, 2000));

      // webhook_base64 = true para receber m√≠dia (imagens, √°udios, docs) em base64
      const enableBase64 = createLineDto.receiveMedia === true;

      try {
        const webhookData = {
          url: webhookUrl,
          enabled: true,
          webhook_by_events: true,
          webhook_base64: enableBase64, // Ativa base64 apenas se linha tiver receiveMedia = true
          events: [
            'MESSAGES_UPSERT',    // Mensagens recebidas/enviadas
            'MESSAGES_UPDATE',     // Atualiza√ß√£o de status (sent, delivered, read)
            'CONNECTION_UPDATE',   // Atualiza√ß√£o de conex√£o
          ],
        };

        console.log('üîó Configurando webhook:', {
          instanceName,
          url: `${evolution.evolutionUrl}/webhook/set/${instanceName}`,
          webhookData,
        });

        const webhookResponse = await axios.post(
          `${evolution.evolutionUrl}/webhook/set/${instanceName}`,
          webhookData,
          {
            headers: {
              'apikey': evolution.evolutionKey,
              'Content-Type': 'application/json',
            },
            timeout: 10000,
          }
        );

        console.log('‚úÖ Webhook configurado com sucesso:', webhookResponse.data);
      } catch (webhookError) {
        console.error('‚ö†Ô∏è Erro ao configurar webhook (formato direto):', {
          error: webhookError.message,
          response: JSON.stringify(webhookError.response?.data, null, 2),
          status: webhookError.response?.status,
        });

        // Tentar formato alternativo com wrapper
        if (webhookError.response?.status === 400 || webhookError.response?.status === 422) {
          console.log('üîÑ Tentando formato alternativo com wrapper webhook...');
          try {
            const alternativePayload = {
              webhook: {
                url: webhookUrl,
                enabled: true,
                webhook_by_events: true,
                webhook_base64: enableBase64,
                events: [
                  'MESSAGES_UPSERT',
                  'MESSAGES_UPDATE',
                  'CONNECTION_UPDATE',
                ],
              },
            };

            console.log('üîó Payload alternativo:', alternativePayload);

            const altResponse = await axios.post(
              `${evolution.evolutionUrl}/webhook/set/${instanceName}`,
              alternativePayload,
              {
                headers: {
                  'apikey': evolution.evolutionKey,
                  'Content-Type': 'application/json',
                },
                timeout: 10000,
              }
            );

            console.log('‚úÖ Webhook configurado com formato alternativo:', altResponse.data);
          } catch (retryError) {
            console.error('‚ùå Erro tamb√©m com formato alternativo:', {
              error: retryError.message,
              response: JSON.stringify(retryError.response?.data, null, 2),
            });
            console.warn('‚ö†Ô∏è Webhook n√£o configurado automaticamente. Configure manualmente na Evolution API.');
          }
        } else {
          console.warn('‚ö†Ô∏è Webhook n√£o configurado automaticamente. Configure manualmente na Evolution API.');
        }
      }

      // Criar linha no banco
      const newLine = await this.prisma.linesStock.create({
        data: {
          ...createLineDto,
          createdBy, // Salvar quem criou a linha
        },
      });

      // Tentar vincular automaticamente a um operador online sem linha do mesmo segmento
      if (newLine.segment) {
        await this.tryAssignLineToOperator(newLine.id, newLine.segment);
      }

      return newLine;
    } catch (error) {
      console.error('‚ùå Erro ao criar linha (detalhado):', {
        message: error.message,
        responseData: JSON.stringify(error.response?.data, null, 2),
        status: error.response?.status,
        url: error.config?.url,
        method: error.config?.method,
        requestData: error.config?.data,
      });

      // Extrair mensagem de erro detalhada
      let errorMsg = 'Erro desconhecido';

      if (error.response?.data?.response?.message) {
        const messages = error.response.data.response.message;
        errorMsg = Array.isArray(messages)
          ? messages.join(', ')
          : messages;
      } else if (error.response?.data?.message) {
        const messages = error.response.data.message;
        errorMsg = Array.isArray(messages)
          ? messages.join(', ')
          : messages;
      } else if (error.response?.data) {
        errorMsg = JSON.stringify(error.response.data);
      } else {
        errorMsg = error.message;
      }

      if (error.message.includes('P2002')) {
        throw new BadRequestException('Telefone j√° cadastrado');
      }

      throw new BadRequestException(`Erro na Evolution API: ${errorMsg}`);
    }
  }

  async findAll(filters?: any) {
    // Remover campos inv√°lidos que n√£o existem no schema
    const { search, lineStatus, ...validFilters } = filters || {};
    
    // Construir where clause
    const where: any = { ...validFilters };
    
    // Aplicar filtro de status se fornecido
    if (lineStatus) {
      where.lineStatus = lineStatus;
    }
    
    // Se houver busca por texto, aplicar filtros
    if (search) {
      where.OR = [
        { phone: { contains: search, mode: 'insensitive' } },
        { evolutionName: { contains: search, mode: 'insensitive' } },
      ];
    }

    // Buscar segmentos para mapeamento
    const segments = await this.prisma.segment.findMany();
    const segmentMap = new Map(segments.map(s => [s.id, s]));

    const lines = await this.prisma.linesStock.findMany({
      where,
      orderBy: {
        createdAt: 'desc',
      },
      include: {
        operators: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
              },
            },
          },
        },
      },
    });

    // Mapear para incluir operadores vinculados e nome do segmento
    return lines.map(line => ({
      ...line,
      segmentName: line.segment ? segmentMap.get(line.segment)?.name : null,
      operators: line.operators.map(lo => ({
        id: lo.user.id,
        name: lo.user.name,
        email: lo.user.email,
      })),
    }));
  }

  async findOne(id: number) {
    const line = await this.prisma.linesStock.findUnique({
      where: { id },
    });

    if (!line) {
      throw new NotFoundException(`Linha com ID ${id} n√£o encontrada`);
    }

    return line;
  }

  async getQRCode(id: number) {
    const line = await this.findOne(id);
    const evolution = await this.prisma.evolution.findUnique({
      where: { evolutionName: line.evolutionName },
    });

    if (!evolution) {
      throw new NotFoundException('Evolution n√£o encontrada para esta linha');
    }

    try {
      const instanceName = `line_${line.phone.replace(/\D/g, '')}`;
      
      // Primeiro, verificar o status da conex√£o
      try {
        const connectionResponse = await axios.get(
          `${evolution.evolutionUrl}/instance/connectionState/${instanceName}`,
          {
            headers: {
              'apikey': evolution.evolutionKey,
            },
          }
        );

        console.log('Status da conex√£o:', connectionResponse.data);
        
        // Se j√° est√° conectado, n√£o precisa de QR Code
        if (connectionResponse.data?.state === 'open' || connectionResponse.data?.instance?.state === 'open') {
          return { qrcode: null, connected: true, message: 'Linha j√° est√° conectada' };
        }
      } catch (connError) {
        console.log('N√£o foi poss√≠vel verificar status da conex√£o, continuando...');
      }

      // Buscar o QR Code
      const response = await axios.get(
        `${evolution.evolutionUrl}/instance/connect/${instanceName}`,
        {
          headers: {
            'apikey': evolution.evolutionKey,
          },
        }
      );

      console.log('Resposta do QR Code:', JSON.stringify(response.data, null, 2));

      // Normalizar a resposta para o formato esperado pelo frontend
      // A Evolution API pode retornar em diferentes formatos
      let qrcode = null;
      
      if (response.data?.base64) {
        // Formato: { base64: "data:image/png;base64,..." }
        qrcode = response.data.base64;
      } else if (response.data?.qrcode?.base64) {
        // Formato: { qrcode: { base64: "..." } }
        qrcode = response.data.qrcode.base64;
      } else if (response.data?.code) {
        // Formato: { code: "texto do qr" } - precisa gerar imagem
        qrcode = response.data.code;
      } else if (typeof response.data === 'string' && response.data.startsWith('data:image')) {
        // Formato: string base64 direto
        qrcode = response.data;
      } else if (response.data?.pairingCode) {
        // Pairing code para WhatsApp Web
        return { 
          qrcode: null, 
          pairingCode: response.data.pairingCode,
          message: 'Use o c√≥digo de pareamento' 
        };
      }

      if (!qrcode) {
        console.warn('Formato de resposta n√£o reconhecido:', response.data);
        // Retornar os dados brutos para debug
        return { 
          qrcode: null, 
          rawData: response.data,
          message: 'QR Code n√£o dispon√≠vel no momento. Verifique se a inst√¢ncia est√° pronta.' 
        };
      }

      return { qrcode };
    } catch (error) {
      console.error('Erro ao obter QR Code:', error.response?.data || error.message);
      
      if (error.response?.status === 404) {
        throw new NotFoundException('Inst√¢ncia n√£o encontrada na Evolution API. Tente recriar a linha.');
      }

      if (error.response?.data?.message) {
        throw new BadRequestException(`Erro na Evolution API: ${error.response.data.message}`);
      }

      throw new BadRequestException(`Erro ao obter QR Code: ${error.message || 'Erro desconhecido'}`);
    }
  }

  async update(id: number, updateLineDto: UpdateLineDto) {
    const currentLine = await this.findOne(id);

    // Se receiveMedia foi alterado, reconfigurar webhook
    if (updateLineDto.receiveMedia !== undefined && updateLineDto.receiveMedia !== currentLine.receiveMedia) {
      await this.updateWebhookConfig(currentLine, updateLineDto.receiveMedia);
    }

    return this.prisma.linesStock.update({
      where: { id },
      data: updateLineDto,
    });
  }

  // Atualiza configura√ß√£o do webhook na Evolution (base64 on/off)
  private async updateWebhookConfig(line: any, enableBase64: boolean) {
    const evolution = await this.prisma.evolution.findUnique({
      where: { evolutionName: line.evolutionName },
    });

    if (!evolution) {
      console.warn('‚ö†Ô∏è Evolution n√£o encontrada para atualizar webhook');
      return;
    }

    try {
      const instanceName = `line_${line.phone.replace(/\D/g, '')}`;
      const webhookUrl = `${process.env.APP_URL || 'http://localhost:3000'}/webhooks/evolution`;

      const webhookData = {
        url: webhookUrl,
        enabled: true,
        webhook_by_events: true,
        webhook_base64: enableBase64,
        events: [
          'MESSAGES_UPSERT',
          'MESSAGES_UPDATE',
          'CONNECTION_UPDATE',
        ],
      };

      console.log(`üîÑ Atualizando webhook base64=${enableBase64} para linha ${line.phone}`);

      await axios.post(
        `${evolution.evolutionUrl}/webhook/set/${instanceName}`,
        webhookData,
        {
          headers: {
            'apikey': evolution.evolutionKey,
            'Content-Type': 'application/json',
          },
          timeout: 10000,
        }
      );

      console.log(`‚úÖ Webhook atualizado com sucesso para linha ${line.phone}`);
    } catch (error) {
      console.error('‚ùå Erro ao atualizar webhook:', error.response?.data || error.message);
    }
  }

  async remove(id: number) {
    const line = await this.findOne(id);

    // Deletar inst√¢ncia na Evolution
    const evolution = await this.prisma.evolution.findUnique({
      where: { evolutionName: line.evolutionName },
    });

    try {
      const instanceName = `line_${line.phone.replace(/\D/g, '')}`;
      await axios.delete(
        `${evolution.evolutionUrl}/instance/delete/${instanceName}`,
        {
          headers: {
            'apikey': evolution.evolutionKey,
          },
        }
      );
    } catch (error) {
      console.error('Erro ao deletar inst√¢ncia na Evolution:', error);
    }

    return this.prisma.linesStock.delete({
      where: { id },
    });
  }

  // L√≥gica autom√°tica de troca de linhas banidas
  async handleBannedLine(lineId: number) {
    const line = await this.findOne(lineId);

    // Buscar todos os operadores vinculados √† linha (tabela LineOperator)
    const lineOperators = await this.prisma.lineOperator.findMany({
      where: { lineId },
      include: {
        user: true,
      },
    });

    const operatorIds = lineOperators.map(lo => lo.userId);

    // Marcar linha como banida
    await this.update(lineId, { lineStatus: 'ban' });

    // Registrar evento de linha banida
    await this.systemEventsService.logEvent(
      EventType.LINE_BANNED,
      EventModule.LINES,
      {
        lineId: line.id,
        linePhone: line.phone,
        operatorsCount: lineOperators.length,
      },
      null,
      EventSeverity.ERROR,
    );

    if (operatorIds.length > 0) {
      console.log(`üîÑ [handleBannedLine] Desvinculando ${operatorIds.length} operador(es) da linha banida ${lineId}`);

      // Buscar conversas ativas (n√£o tabuladas) da linha banida, agrupadas por operador
      const activeConversations = await this.prisma.conversation.findMany({
        where: {
          userLine: lineId,
          tabulation: null, // Apenas conversas ativas
          userId: { in: operatorIds }, // Apenas dos operadores desta linha
        },
        select: {
          contactPhone: true,
          contactName: true,
          userId: true,
        },
        distinct: ['contactPhone', 'userId'], // Evitar duplicatas
      });

      // Agrupar contatos por operador
      const contactsByOperator = new Map<number, Array<{ phone: string; name: string }>>();
      activeConversations.forEach(conv => {
        if (conv.userId) {
          if (!contactsByOperator.has(conv.userId)) {
            contactsByOperator.set(conv.userId, []);
          }
          contactsByOperator.get(conv.userId)!.push({
            phone: conv.contactPhone,
            name: conv.contactName,
          });
        }
      });

      // Desvincular todos os operadores da tabela LineOperator
      await this.prisma.lineOperator.deleteMany({
        where: { lineId },
      });

      // Atualizar campos legacy (line e linkedTo)
      for (const operatorId of operatorIds) {
        await this.prisma.user.update({
          where: { id: operatorId },
          data: { line: null },
        });
      }

      // Limpar linkedTo da linha banida
      await this.prisma.linesStock.update({
        where: { id: lineId },
        data: { linkedTo: null },
      });

      // Tentar atribuir novas linhas aos operadores desvinculados
      for (const operatorId of operatorIds) {
        const operator = await this.prisma.user.findUnique({
          where: { id: operatorId },
          include: { lineOperators: true },
        });

        if (!operator || operator.lineOperators.length > 0) {
          continue; // Operador j√° tem outra linha ou n√£o existe
        }

        // 1. Primeiro, tentar buscar linha do mesmo segmento do operador
        let availableLines = await this.prisma.linesStock.findMany({
          where: {
            lineStatus: 'active',
            segment: operator.segment || line.segment,
          },
          include: {
            operators: {
              include: {
                user: true,
              },
            },
          },
        });

        // Filtrar por evolutions ativas
        availableLines = await this.controlPanelService.filterLinesByActiveEvolutions(availableLines, operator.segment || undefined);

        // Aceitar linhas com menos de 2 operadores e que n√£o tenham operadores de outro segmento
        let availableLine = availableLines.find(l => {
          if (l.operators.length >= 2) return false;
          
          // Verificar se todos os operadores s√£o do mesmo segmento do operador atual
          if (l.operators.length > 0 && operator.segment) {
            const allSameSegment = l.operators.every(lo => lo.user.segment === operator.segment);
            if (!allSameSegment) return false;
          }
          
          return true;
        });

        // 2. Se n√£o encontrou linha do segmento, buscar linha do segmento "Padr√£o"
        if (!availableLine) {
          // Buscar o segmento "Padr√£o" pelo nome (criado na seed)
          const defaultSegment = await this.prisma.segment.findUnique({
            where: { name: 'Padr√£o' },
          });

          if (defaultSegment) {
            const defaultLines = await this.prisma.linesStock.findMany({
              where: {
                lineStatus: 'active',
                segment: defaultSegment.id, // Segmento "Padr√£o" pelo ID
              },
              include: {
                operators: {
                  include: {
                    user: true,
                  },
                },
              },
            });

            // Filtrar por evolutions ativas
            const filteredDefaultLines = await this.controlPanelService.filterLinesByActiveEvolutions(defaultLines, operator.segment || undefined);

            // Linhas padr√£o podem aceitar qualquer operador se tiverem menos de 2
            availableLine = filteredDefaultLines.find(l => l.operators.length < 2);
          }
        }

        if (availableLine) {
          // Vincular nova linha ao operador usando a tabela LineOperator
          await this.assignOperatorToLine(availableLine.id, operatorId);
          console.log(`‚úÖ [handleBannedLine] Linha ${availableLine.phone} atribu√≠da ao operador ${operator.name} (ID: ${operatorId})`);
          
          // IMPORTANTE: Atualizar userLine das conversas ativas para a nova linha
          // Isso mant√©m as conversas vinculadas ao operador, mas usando a nova linha
          await this.prisma.conversation.updateMany({
            where: {
              userId: operatorId,
              userLine: lineId, // Linha banida
              tabulation: null, // Apenas conversas ativas
            },
            data: {
              userLine: availableLine.id, // Nova linha
            },
          });
          console.log(`üîÑ [handleBannedLine] Conversas do operador ${operator.name} atualizadas para usar a nova linha ${availableLine.phone}`);
          
          // N√ÉO notificar o operador - ele n√£o precisa saber que a linha foi banida
          // As conversas continuam aparecendo normalmente
        } else {
          console.warn(`‚ö†Ô∏è [handleBannedLine] Nenhuma linha dispon√≠vel para substituir a linha banida para o operador ${operator?.name || operatorId}`);
          
          // Fechar conversas ativas do operador
          try {
            await this.prisma.conversation.updateMany({
              where: {
                userId: operatorId,
                userLine: lineId,
                tabulation: null, // Apenas conversas n√£o tabuladas
              },
              data: {
                tabulation: -1, // Marcar como fechada (usar -1 como c√≥digo especial)
              },
            });
            console.log(`üîÑ [handleBannedLine] Conversas ativas do operador ${operator?.name || operatorId} foram fechadas`);
          } catch (error) {
            console.error(`‚ùå [handleBannedLine] Erro ao fechar conversas:`, error);
          }
          
          // Notificar operador via WebSocket
          try {
            const operatorSockets = Array.from(this.websocketGateway['connectedUsers']?.entries() || [])
              .filter(([_, socket]: [any, any]) => socket.data?.user?.id === operatorId)
              .map(([_, socket]: [any, any]) => socket);
            
            for (const socket of operatorSockets) {
              socket.emit('line-lost', {
                message: 'Sua linha foi removida e n√£o h√° linha dispon√≠vel no momento. Voc√™ ser√° notificado quando uma nova linha for atribu√≠da.',
              });
            }
          } catch (error) {
            console.error(`‚ùå [handleBannedLine] Erro ao notificar operador:`, error);
          }
          
          // Log apenas - fila de espera n√£o implementada no schema ainda
          console.log(`üìã [handleBannedLine] Operador ${operator?.name || operatorId} precisa de nova linha, mas nenhuma dispon√≠vel no momento`);
        }
      }
    } else if (line.linkedTo) {
      // Fallback: se n√£o h√° operadores na tabela LineOperator mas h√° linkedTo (legacy)
      await this.prisma.user.update({
        where: { id: line.linkedTo },
        data: { line: null },
      });

      // Buscar uma nova linha ativa do mesmo segmento
      const availableLine = await this.prisma.linesStock.findFirst({
        where: {
          lineStatus: 'active',
          segment: line.segment,
          linkedTo: null,
        },
      });

      if (availableLine) {
        // Vincular nova linha ao operador
        await this.update(availableLine.id, { linkedTo: line.linkedTo });
        await this.prisma.user.update({
          where: { id: line.linkedTo },
          data: { line: availableLine.id },
        });

        console.log(`‚úÖ [handleBannedLine] Linha ${availableLine.phone} atribu√≠da ao operador ${line.linkedTo} (legacy)`);
      } else {
        console.warn(`‚ö†Ô∏è [handleBannedLine] Nenhuma linha dispon√≠vel para substituir a linha banida`);
      }
    }

    console.log(`‚úÖ [handleBannedLine] Linha ${lineId} marcada como banida e operadores desvinculados`);
  }

  async getAvailableLines(segment: number) {
    return this.prisma.linesStock.findMany({
      where: {
        lineStatus: 'active',
        segment,
        linkedTo: null,
      },
    });
  }

  async getAvailableLinesForOperator(operatorId: number) {
    // Buscar operador
    const operator = await this.prisma.user.findUnique({
      where: { id: operatorId },
      select: { segment: true },
    });

    if (!operator) {
      throw new NotFoundException('Operador n√£o encontrado');
    }

    // Buscar linhas dispon√≠veis do segmento do operador
    let availableLines = await this.prisma.linesStock.findMany({
      where: {
        lineStatus: 'active',
        segment: operator.segment,
      },
      include: {
        operators: true,
      },
    });

    // Filtrar linhas com menos de 2 operadores
    availableLines = availableLines.filter(l => l.operators.length < 2);

    // Se n√£o encontrou linhas do segmento, buscar linhas sem segmento (padr√£o)
    if (availableLines.length === 0) {
      const defaultLines = await this.prisma.linesStock.findMany({
        where: {
          lineStatus: 'active',
          segment: null,
        },
        include: {
          operators: true,
        },
      });
      availableLines = defaultLines.filter(l => l.operators.length < 2);
    }

    // Filtrar por evolutions ativas
    const filteredLines = await this.controlPanelService.filterLinesByActiveEvolutions(
      availableLines,
      operator.segment || undefined
    );

    // Buscar segmentos para mapear nomes
    const segments = await this.prisma.segment.findMany();
    const segmentMap = new Map(segments.map(s => [s.id, s]));

    return filteredLines.map(line => ({
      id: line.id,
      phone: line.phone,
      segment: line.segment,
      segmentName: line.segment ? segmentMap.get(line.segment)?.name : 'Sem segmento',
      operatorsCount: line.operators.length,
    }));
  }

  async getEvolutions() {
    return this.prisma.evolution.findMany({
      orderBy: {
        evolutionName: 'asc',
      },
    });
  }

  private async getAvailableEvolutionNames(): Promise<string> {
    const evolutions = await this.prisma.evolution.findMany({
      select: { evolutionName: true },
    });
    return evolutions.map(e => e.evolutionName).join(', ') || 'nenhuma';
  }

  async fetchInstancesFromEvolution(evolutionName: string) {
    const evolution = await this.prisma.evolution.findUnique({
      where: { evolutionName },
    });

    if (!evolution) {
      throw new NotFoundException('Evolution n√£o encontrada');
    }

    try {
      const response = await axios.get(
        `${evolution.evolutionUrl}/instance/fetchInstances`,
        {
          headers: {
            'apikey': evolution.evolutionKey,
          },
          params: {
            instanceName: evolutionName,
          },
        }
      );

      return response.data;
    } catch (error) {
      console.error('Erro ao buscar inst√¢ncias:', error.response?.data || error.message);
      throw new BadRequestException('Erro ao buscar inst√¢ncias da Evolution API');
    }
  }

  // Distribuir mensagem inbound entre os operadores da linha (m√°ximo 2)
  // Retorna o ID do operador que deve receber a mensagem
  async assignInboundMessageToOperator(lineId: number, contactPhone: string): Promise<number | null> {
    // Buscar operadores vinculados √† linha
    const lineOperators = await this.prisma.lineOperator.findMany({
      where: { lineId },
      include: {
        user: true,
      },
    });

    console.log(`üîç [LinesService] Buscando operadores para linha ${lineId}:`, {
      totalVinculados: lineOperators.length,
      operadores: lineOperators.map(lo => ({
        userId: lo.userId,
        userName: lo.user.name,
        status: lo.user.status,
        role: lo.user.role,
      })),
    });

    // Filtrar apenas operadores online
    const onlineOperators = lineOperators
      .filter(lo => lo.user.status === 'Online' && lo.user.role === 'operator')
      .map(lo => lo.user);

    console.log(`üîç [LinesService] Operadores online na linha ${lineId}:`, {
      totalOnline: onlineOperators.length,
      operadores: onlineOperators.map(op => ({
        id: op.id,
        name: op.name,
        status: op.status,
      })),
    });

    if (onlineOperators.length === 0) {
      console.log(`‚ö†Ô∏è [LinesService] Nenhum operador online na linha ${lineId}`);
      
      // Verificar se h√° operadores vinculados mas offline
      const offlineOperators = lineOperators.filter(lo => lo.user.status !== 'Online');
      if (offlineOperators.length > 0) {
        console.log(`‚ÑπÔ∏è [LinesService] H√° ${offlineOperators.length} operador(es) vinculado(s) mas offline:`, 
          offlineOperators.map(lo => `${lo.user.name} (${lo.user.status})`));
      }
      
      // FALLBACK: Se n√£o encontrou na tabela LineOperator, verificar campo legacy (linkedTo)
      const line = await this.prisma.linesStock.findUnique({
        where: { id: lineId },
      });
      
      if (line && line.linkedTo) {
        const legacyOperator = await this.prisma.user.findUnique({
          where: { id: line.linkedTo },
        });
        
        if (legacyOperator && legacyOperator.status === 'Online' && legacyOperator.role === 'operator') {
          console.log(`‚úÖ [LinesService] Fallback: Encontrado operador legacy online: ${legacyOperator.name} (ID: ${legacyOperator.id})`);
          
          // Sincronizar: criar entrada na tabela LineOperator
          const existingLink = await this.prisma.lineOperator.findFirst({
            where: {
              lineId: lineId,
              userId: legacyOperator.id,
            },
          });
          
          if (!existingLink) {
            await this.prisma.lineOperator.create({
              data: {
                lineId: lineId,
                userId: legacyOperator.id,
              },
            });
            console.log(`‚úÖ [LinesService] Operador legacy sincronizado na tabela LineOperator`);
          }
          
          return legacyOperator.id;
        }
      }
      
      return null;
    }

    // Usar transaction com lock para evitar race condition
    return await this.prisma.$transaction(async (tx) => {
      // Verificar se j√° existe conversa ativa com algum operador espec√≠fico (com lock)
      const existingConversation = await tx.conversation.findFirst({
        where: {
          contactPhone,
          userLine: lineId,
          tabulation: null, // Conversa n√£o tabulada (ativa)
          userId: { in: onlineOperators.map(op => op.id) },
        },
        orderBy: {
          datetime: 'desc',
        },
      });

      // Se j√° existe conversa ativa, atribuir ao mesmo operador
      if (existingConversation && existingConversation.userId) {
        console.log(`‚úÖ [LinesService] Mensagem atribu√≠da ao operador existente: ${existingConversation.userId}`);
        return existingConversation.userId;
      }

      // Distribuir de forma round-robin: contar conversas ativas de cada operador (com lock)
      const operatorConversationCounts = await Promise.all(
        onlineOperators.map(async (operator) => {
          const count = await tx.conversation.count({
            where: {
              userLine: lineId,
              userId: operator.id,
              tabulation: null, // Apenas conversas ativas
            },
          });
          return { operatorId: operator.id, count };
        })
      );

      // Ordenar por menor n√∫mero de conversas (balanceamento)
      operatorConversationCounts.sort((a, b) => a.count - b.count);

      // Retornar o operador com menos conversas
      const selectedOperatorId = operatorConversationCounts[0]?.operatorId || onlineOperators[0]?.id;
      console.log(`‚úÖ [LinesService] Mensagem atribu√≠da ao operador ${selectedOperatorId} (${operatorConversationCounts[0]?.count || 0} conversas ativas)`);
      
      return selectedOperatorId || null;
    }, { isolationLevel: 'Serializable' });
  }

  // Vincular operador √† linha (m√°ximo 2 operadores por linha)
  // Usa transa√ß√£o + lock para evitar race conditions
  async assignOperatorToLine(lineId: number, userId: number): Promise<void> {
    // Usar transa√ß√£o com lock para evitar race conditions
    return await this.prisma.$transaction(async (tx) => {
      // Lock na linha para evitar atribui√ß√µes simult√¢neas
      const line = await tx.linesStock.findUnique({
        where: { id: lineId },
      });

      if (!line) {
        throw new NotFoundException('Linha n√£o encontrada');
      }

      if (line.lineStatus !== 'active') {
        throw new BadRequestException('Linha n√£o est√° ativa');
      }

      // Verificar se a linha est√° em uma evolution ativa
      const activeEvolutions = await this.controlPanelService.getActiveEvolutions();
      if (activeEvolutions && activeEvolutions.length > 0 && !activeEvolutions.includes(line.evolutionName)) {
        throw new BadRequestException(`Linha da evolution '${line.evolutionName}' n√£o est√° ativa para atribui√ß√£o`);
      }

      // Verificar se a linha j√° tem 2 operadores (com lock)
      const currentOperators = await tx.lineOperator.count({
        where: { lineId },
      });

      if (currentOperators >= 2) {
        throw new BadRequestException('Linha j√° possui o m√°ximo de 2 operadores vinculados');
      }

      // Verificar se o operador j√° est√° vinculado a esta linha
      const existing = await tx.lineOperator.findUnique({
        where: {
          lineId_userId: {
            lineId,
            userId,
          },
        },
      });

      if (existing) {
        throw new BadRequestException('Operador j√° est√° vinculado a esta linha');
      }

      // Verificar se operador j√° tem outra linha
      const operatorCurrentLine = await tx.lineOperator.findFirst({
        where: { userId },
      });

      if (operatorCurrentLine && operatorCurrentLine.lineId !== lineId) {
        // Desvincular da linha anterior
        await tx.lineOperator.deleteMany({
          where: { userId, lineId: operatorCurrentLine.lineId },
        });
      }

      // Criar v√≠nculo
      await tx.lineOperator.create({
        data: {
          lineId,
          userId,
        },
      });

      // Atualizar campo legacy para compatibilidade
      await tx.user.update({
        where: { id: userId },
        data: { line: lineId },
      });

      // Atualizar linkedTo apenas se for o primeiro operador
      if (currentOperators === 0) {
        await tx.linesStock.update({
          where: { id: lineId },
          data: { linkedTo: userId },
        });
      }

      console.log(`‚úÖ Operador ${userId} vinculado √† linha ${lineId} (com lock)`);
    }, {
      isolationLevel: 'Serializable', // N√≠vel mais alto de isolamento para evitar race conditions
      timeout: 10000, // 10 segundos de timeout
    });
  }

  // Desvincular operador da linha
  async unassignOperatorFromLine(lineId: number, userId: number): Promise<void> {
    await this.prisma.lineOperator.deleteMany({
      where: {
        lineId,
        userId,
      },
    });

    // Atualizar campo legacy
    await this.prisma.user.update({
      where: { id: userId },
      data: { line: null },
    });

    // Se era o primeiro operador (linkedTo), atualizar para o pr√≥ximo
    const line = await this.prisma.linesStock.findUnique({
      where: { id: lineId },
    });

    if (line && line.linkedTo === userId) {
      const remainingOperator = await this.prisma.lineOperator.findFirst({
        where: { lineId },
      });

      await this.prisma.linesStock.update({
        where: { id: lineId },
        data: { linkedTo: remainingOperator?.userId || null },
      });
    }

    console.log(`‚úÖ Operador ${userId} desvinculado da linha ${lineId}`);
  }

  // Relat√≥rio de produtividade dos ativadores
  async getActivatorsProductivity() {
    const activators = await this.prisma.user.findMany({
      where: {
        role: 'ativador',
      },
      include: {
        createdLines: {
          select: {
            id: true,
            phone: true,
            lineStatus: true,
            createdAt: true,
          },
        },
      },
    });

    const productivity = activators.map(activator => {
      const totalLines = activator.createdLines.length;
      const activeLines = activator.createdLines.filter(l => l.lineStatus === 'active').length;
      const bannedLines = activator.createdLines.filter(l => l.lineStatus === 'ban').length;

      // Agrupar por m√™s
      const linesByMonth = activator.createdLines.reduce((acc, line) => {
        const month = new Date(line.createdAt).toLocaleString('pt-BR', { month: 'long', year: 'numeric' });
        acc[month] = (acc[month] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);

      return {
        id: activator.id,
        name: activator.name,
        email: activator.email,
        totalLines,
        activeLines,
        bannedLines,
        linesByMonth,
        createdAt: activator.createdAt,
        updatedAt: activator.updatedAt, // √öltima atualiza√ß√£o (pode indicar √∫ltimo login)
      };
    });

    return productivity.sort((a, b) => b.totalLines - a.totalLines); // Ordenar por total de linhas (maior primeiro)
  }

  /**
   * Busca estat√≠sticas de aloca√ß√£o de linhas com operadores
   */
  async getLinesAllocationStats() {
    // Total de linhas ativas
    const totalActiveLines = await this.prisma.linesStock.count({
      where: { lineStatus: 'active' },
    });

    // Buscar todas as linhas ativas com seus operadores
    const activeLines = await this.prisma.linesStock.findMany({
      where: { lineStatus: 'active' },
      include: {
        operators: true,
      },
    });

    // Contar linhas com v√≠nculo (pelo menos 1 operador)
    const linesWithOperatorsCount = activeLines.filter(line => line.operators.length > 0).length;

    // Linhas sem v√≠nculo
    const linesWithoutOperatorsCount = totalActiveLines - linesWithOperatorsCount;

    // Linhas com 1 operador
    const linesWithOneOperatorCount = activeLines.filter(line => line.operators.length === 1).length;

    // Linhas com 2 operadores
    const linesWithTwoOperatorsCount = activeLines.filter(line => line.operators.length === 2).length;

    return {
      totalActiveLines,
      linesWithOperators: linesWithOperatorsCount,
      linesWithoutOperators: linesWithoutOperatorsCount,
      linesWithOneOperator: linesWithOneOperatorCount,
      linesWithTwoOperators: linesWithTwoOperatorsCount,
    };
  }

  // Tentar vincular linha automaticamente a operadores online sem linha do mesmo segmento (m√°ximo 2)
  private async tryAssignLineToOperator(lineId: number, segment: number) {
    try {
      // Buscar operador online sem linha do mesmo segmento
      // Verificar quantos operadores j√° est√£o vinculados
      const currentOperatorsCount = await this.prisma.lineOperator.count({
        where: { lineId },
      });

      if (currentOperatorsCount >= 2) {
        console.log(`‚ÑπÔ∏è [LinesService] Linha ${lineId} j√° possui 2 operadores vinculados`);
        return;
      }

      // Buscar operadores online sem linha do mesmo segmento
      // Primeiro, buscar todos os operadores online do segmento
      const allOnlineOperators = await this.prisma.user.findMany({
        where: {
          role: 'operator',
          status: 'Online',
          segment: segment,
        },
      });

      // Filtrar apenas os que n√£o t√™m v√≠nculo com nenhuma linha
      const operatorsWithoutLine = [];
      for (const operator of allOnlineOperators) {
        const hasLine = await this.prisma.lineOperator.findFirst({
          where: { userId: operator.id },
        });
        if (!hasLine && operatorsWithoutLine.length < (2 - currentOperatorsCount)) {
          operatorsWithoutLine.push(operator);
        }
      }

      for (const operator of operatorsWithoutLine) {
        try {
          await this.assignOperatorToLine(lineId, operator.id);

          // Notificar operador via WebSocket
          if (this.websocketGateway) {
            const line = await this.findOne(lineId);
            this.websocketGateway.emitToUser(operator.id, 'line-assigned', {
              lineId: lineId,
              linePhone: line.phone,
              message: `Voc√™ foi vinculado √† linha ${line.phone} automaticamente.`,
            });
          }

          console.log(`‚úÖ [LinesService] Linha ${lineId} vinculada automaticamente ao operador ${operator.name} (segmento ${segment})`);
        } catch (error) {
          console.error(`‚ùå [LinesService] Erro ao vincular operador ${operator.id} √† linha ${lineId}:`, error.message);
        }
      }

      if (operatorsWithoutLine.length === 0) {
        console.log(`‚ÑπÔ∏è [LinesService] Nenhum operador online sem linha encontrado no segmento ${segment} para vincular a linha ${lineId}`);
      }
    } catch (error) {
      console.error('‚ùå [LinesService] Erro ao tentar vincular linha automaticamente:', error);
      // N√£o lan√ßar erro, apenas logar - a linha foi criada com sucesso
    }
  }
}
